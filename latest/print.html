<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for C#/.NET Developers</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded affix "><a href="license.html">许可</a></li><li class="chapter-item expanded affix "><a href="contributing.html">贡献指南</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="language/index.html"><strong aria-hidden="true">2.</strong> 语言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/scalar-types.html"><strong aria-hidden="true">2.1.</strong> 标量类型</a></li><li class="chapter-item expanded "><a href="language/strings.html"><strong aria-hidden="true">2.2.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="language/structured-types.html"><strong aria-hidden="true">2.3.</strong> 复合类型</a></li><li class="chapter-item expanded "><a href="language/custom-types/index.html"><strong aria-hidden="true">2.4.</strong> 自定义类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/custom-types/classes.html"><strong aria-hidden="true">2.4.1.</strong> 类（Class）</a></li><li class="chapter-item expanded "><a href="language/custom-types/records.html"><strong aria-hidden="true">2.4.2.</strong> 记录（Record）</a></li><li class="chapter-item expanded "><a href="language/custom-types/structs.html"><strong aria-hidden="true">2.4.3.</strong> 结构（Struct）</a></li><li class="chapter-item expanded "><a href="language/custom-types/interfaces.html"><strong aria-hidden="true">2.4.4.</strong> 接口（Interfaces）</a></li><li class="chapter-item expanded "><a href="language/custom-types/enums.html"><strong aria-hidden="true">2.4.5.</strong> 枚举（Enum）</a></li><li class="chapter-item expanded "><a href="language/custom-types/members.html"><strong aria-hidden="true">2.4.6.</strong> 成员（Members）</a></li></ol></li><li class="chapter-item expanded "><a href="language/local-functions.html"><strong aria-hidden="true">2.5.</strong> 本地函数</a></li><li class="chapter-item expanded "><a href="language/lambda-and-closures.html"><strong aria-hidden="true">2.6.</strong> Lambda表达式与闭包</a></li><li class="chapter-item expanded "><a href="language/variables.html"><strong aria-hidden="true">2.7.</strong> 变量</a></li><li class="chapter-item expanded "><a href="language/namespaces.html"><strong aria-hidden="true">2.8.</strong> 命名空间</a></li><li class="chapter-item expanded "><a href="language/equality.html"><strong aria-hidden="true">2.9.</strong> 相等性</a></li><li class="chapter-item expanded "><a href="language/generics.html"><strong aria-hidden="true">2.10.</strong> 泛型</a></li><li class="chapter-item expanded "><a href="language/polymorphism.html"><strong aria-hidden="true">2.11.</strong> 多态</a></li><li class="chapter-item expanded "><a href="language/inheritance.html"><strong aria-hidden="true">2.12.</strong> 继承</a></li><li class="chapter-item expanded "><a href="language/exception-handling.html"><strong aria-hidden="true">2.13.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="language/nullability-and-optionality.html"><strong aria-hidden="true">2.14.</strong> Nullable 和 Option</a></li><li class="chapter-item expanded "><a href="language/discards.html"><strong aria-hidden="true">2.15.</strong> 弃元</a></li><li class="chapter-item expanded "><a href="language/conversion-and-casting.html"><strong aria-hidden="true">2.16.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="language/operator-overloading.html"><strong aria-hidden="true">2.17.</strong> 运算符重载</a></li><li class="chapter-item expanded "><a href="language/documentation-comments.html"><strong aria-hidden="true">2.18.</strong> 文档注释</a></li></ol></li><li class="chapter-item expanded "><a href="memory-management/index.html"><strong aria-hidden="true">3.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="resource-management/index.html"><strong aria-hidden="true">4.</strong> 资源管理</a></li><li class="chapter-item expanded "><a href="threading/index.html"><strong aria-hidden="true">5.</strong> 线程操作</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threading/synchronization.html"><strong aria-hidden="true">5.1.</strong> 同步</a></li><li class="chapter-item expanded "><a href="threading/producer-consumer.html"><strong aria-hidden="true">5.2.</strong> 生产者-消费者</a></li></ol></li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">6.</strong> 测试</a></li><li class="chapter-item expanded "><a href="benchmarking/index.html"><strong aria-hidden="true">7.</strong> 基准测试</a></li><li class="chapter-item expanded "><a href="logging-and-tracing/index.html"><strong aria-hidden="true">8.</strong> 日志记录和跟踪</a></li><li class="chapter-item expanded "><a href="conditional-compilation/index.html"><strong aria-hidden="true">9.</strong> 条件编译</a></li><li class="chapter-item expanded "><a href="environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> 环境与配置</a></li><li class="chapter-item expanded "><a href="linq/index.html"><strong aria-hidden="true">11.</strong> LINQ</a></li><li class="chapter-item expanded "><a href="meta-programming/index.html"><strong aria-hidden="true">12.</strong> 元编程</a></li><li class="chapter-item expanded "><a href="asynchronous-programming/index.html"><strong aria-hidden="true">13.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="project-structure/index.html"><strong aria-hidden="true">14.</strong> 项目结构</a></li><li class="chapter-item expanded "><a href="compilation-and-building/index.html"><strong aria-hidden="true">15.</strong> 编译与构建</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for C#/.NET Developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/artiga033/rust-for-dotnet-devs-zh-CN" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>这是一本面向完全未接触过 Rust 的 C# 和 .NET 开发者的(不完全)指南。Rust 和 C# 中的一些概念和形式都可以很好地转换，仅仅是表达方式不同，也有一些是完全不同的，例如内存管理。本书通过一些简明的样例来简单对照和比较这些形式和概念。</p>
<p>本书的原作者<sup class="footnote-reference"><a href="#authors">1</a></sup>都是全新接触 Rust 的 C#/.NET 开发者。这本指南是这些作者在几个月的课程中编写 Rust 代码时的知识汇集，也正是作者们开始他们的 Rust 之旅时最期望看到的指南。也就是说，作者们同样鼓励你通过更多书籍和网络材料来深入 Rust，而不是仅仅透过 C# 和 .NET 观察。同时，本指南可以快速地解决一些疑问，例如：<em>Rust是否支持继承，多线程，异步编程等？</em></p>
<p>本书假定：</p>
<ul>
<li>读者是一名经验丰富的 C#/.NET 开发者。</li>
<li>读者对 Rust 是完全陌生的 。</li>
</ul>
<p>本书目标：</p>
<ul>
<li>简要的对比 C#/.NET 的若干话题和它们对应的 Rust 版本。</li>
<li>提供深入探究这些话题的 Rust 参考、书籍、文章链接<sup class="footnote-reference"><a href="#localization">2</a></sup>。</li>
</ul>
<p>非本书目标：</p>
<ul>
<li>对设计模式和架构的讨论</li>
<li>Rust 语言教程</li>
<li>读者能在阅读后精通 Rust</li>
<li>尽管有许多示例用于对比 C# 和 Rust，请注意本书并非是它们两者的编码用例指南。</li>
</ul>
<hr />
<div class="footnote-definition" id="authors"><sup class="footnote-definition-label">1</sup>
<p>本指南的原作者是（字母序）：
<a href="https://github.com/atifaziz">Atif Aziz</a>, <a href="https://github.com/bastbu">Bastian Burger</a>, <a href="https://github.com/danigian">Daniele Antonio Maggio</a>, <a href="https://github.com/dariuszparys">Dariusz Parys</a>, <a href="https://github.com/p-schuler">Patrick Schuler</a>.</p>
</div>
<div class="footnote-definition" id="translators"><sup class="footnote-definition-label">3</sup>
<p>译者注①：此译本的贡献者为：<a href="https://github.com/artiga033">artiga033</a></p>
</div>
<div class="footnote-definition" id="localization"><sup class="footnote-definition-label">2</sup>
<p>译者注②：为本地化考虑，此译本替换了部分链接为对应的中文版本，具体参见<a href="./contributing.html#%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%A4%96%E9%83%A8%E5%BC%95%E7%94%A8%E7%B4%A2%E5%BC%95">本地化外部引用索引</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="许可"><a class="header" href="#许可">许可</a></h1>
<p>Original Copy:</p>
<blockquote>
Copyright &copy; Microsoft Corporation.<br>
Portions Copyright &copy; 2010 The Rust Project Developers
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE</p>
</blockquote>
<p>This translation:</p>
<blockquote>
Copyright &copy; zh-CN translators
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE</p>
<blockquote/>
<div style="break-before: page; page-break-before: always;"></div><h1 id="贡献指南"><a class="header" href="#贡献指南">贡献指南</a></h1>
<p><strong>译者注：本节与原文不同，仅特定于此翻译版本。</strong></p>
<p>如果您有关于原书内容的任何补充和见解，请提交至<a href="https://github.com/microsoft/rust-for-dotnet-devs/blob/main/src/contributing.md">英文原版</a>。</p>
<p>欢迎参与翻译或修订/更新内容，请及时发 Issue 或 Pull Request 以便其他人知道您的工作，防止重复劳动。</p>
<h2 id="本地化外部引用索引"><a class="header" href="#本地化外部引用索引">本地化外部引用索引</a></h2>
<p>英文原版中引用的外部文档有相当一部分已有社区或官方的中文翻译，为了方便中文读者，我们将一部分有中文对应版本的链接替换为了对应的中文版本，具体参见下表：</p>
<div class="table-wrapper"><table><thead><tr><th>原站</th><th>中文版</th><th>备注</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></td><td><a href="https://kaisery.github.io/trpl-zh-cn/">https://kaisery.github.io/trpl-zh-cn/</a></td><td></td></tr>
<tr><td><a href="https://www.rust-lang.org">https://www.rust-lang.org</a></td><td><a href="https://www.rust-lang.org/zh-CN/">https://www.rust-lang.org/zh-CN/</a></td><td></td></tr>
<tr><td><a href="https://learn.microsoft.com/en-us/">https://learn.microsoft.com/en-us/</a></td><td><a href="https://learn.microsoft.com/zh-cn/">https://learn.microsoft.com/zh-cn/</a></td><td>可能有机翻</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>使用 <a href="https://play.rust-lang.org/">Rust Playground</a> 是最简单的一种不需要 本地安装就能体验 Rust 的方法。它是一个极简的开发前端，运行在浏览器中，并且可以编写和运行 Rust 代码。</p>
<h2 id="dev-container"><a class="header" href="#dev-container">Dev Container</a></h2>
<p><a href="https://play.rust-lang.org/">Rust Playground</a> 的执行环境有一些限制，例如总编译/执行时长，内存和网络等，还有另一个不需要安装 Rust 的方法是使用 <em>dev container</em>，例如 <a href="https://github.com/microsoft/vscode-remote-try-rust">https://github.com/microsoft/vscode-remote-try-rust</a> 这个仓库中提供的。就像 Rust Playground, dev container 可以直接在浏览器中运行，可以使用<a href="https://github.com/features/codespaces">Github Codespaces</a> 或 <a href="https://code.visualstudio.com/docs/devcontainers/containers">使用本地的 Visual Studio Code</a></p>
<h2 id="本地安装"><a class="header" href="#本地安装">本地安装</a></h2>
<p>要获取完整的 Rust 编译器和开发工具，参见 <a href="https://kaisery.github.io/trpl-zh-cn/">Rust 程序设计语言</a> 一书中<a href="https://kaisery.github.io/trpl-zh-cn/ch01-00-getting-started.html">入门指南</a>一章的<a href="https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html">安装</a>小节，或是<a href="https://www.rust-lang.org/zh-CN/">rust-lang.org</a>上的<a href="https://www.rust-lang.org/zh-CN/tools/install">安装页面</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语言"><a class="header" href="#语言">语言</a></h1>
<p>本节对比 C# 和 Rust 的语言特性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标量类型"><a class="header" href="#标量类型">标量类型</a></h1>
<p>下表展示了 Rust 中的原生类型（primitive types）和它们在 C# 和 .NET 中的等价物：</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>C#</th><th>.NET</th><th>备注</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>bool</code></td><td><code>Boolean</code></td><td></td></tr>
<tr><td><code>char</code></td><td><code>char</code></td><td><code>Char</code></td><td>参见备注 1.</td></tr>
<tr><td><code>i8</code></td><td><code>sbyte</code></td><td><code>SByte</code></td><td></td></tr>
<tr><td><code>i16</code></td><td><code>short</code></td><td><code>Int16</code></td><td></td></tr>
<tr><td><code>i32</code></td><td><code>int</code></td><td><code>Int32</code></td><td></td></tr>
<tr><td><code>i64</code></td><td><code>long</code></td><td><code>Int64</code></td><td></td></tr>
<tr><td><code>i128</code></td><td></td><td><code>Int128</code></td><td></td></tr>
<tr><td><code>isize</code></td><td><code>nint</code></td><td><code>IntPtr</code></td><td></td></tr>
<tr><td><code>u8</code></td><td><code>byte</code></td><td><code>Byte</code></td><td></td></tr>
<tr><td><code>u16</code></td><td><code>ushort</code></td><td><code>UInt16</code></td><td></td></tr>
<tr><td><code>u32</code></td><td><code>uint</code></td><td><code>UInt32</code></td><td></td></tr>
<tr><td><code>u64</code></td><td><code>ulong</code></td><td><code>UInt64</code></td><td></td></tr>
<tr><td><code>u128</code></td><td></td><td><code>UInt128</code></td><td></td></tr>
<tr><td><code>usize</code></td><td><code>nuint</code></td><td><code>UIntPtr</code></td><td></td></tr>
<tr><td><code>f32</code></td><td><code>float</code></td><td><code>Single</code></td><td></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td><td><code>Double</code></td><td></td></tr>
<tr><td></td><td><code>decimal</code></td><td><code>Decimal</code></td><td></td></tr>
<tr><td><code>()</code></td><td><code>void</code></td><td><code>Void</code> 或 <code>ValueTuple</code></td><td>参见备注 2 &amp; 3.</td></tr>
<tr><td></td><td><code>object</code></td><td><code>Object</code></td><td>参见备注 3.</td></tr>
</tbody></table>
</div>
<p>备注：</p>
<ol>
<li>Rust中的 <a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a> 和 .NET 中的 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.char"><code>Char</code></a> 的定义不同。在Rust中，<code>char</code> 是一个四字节宽的<a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode 标量值</a>，但是在.NET中，<code>Char</code> 是两字节宽的，它保存的该字符的UTF-16编码。更多信息参见<a href="https://doc.rust-lang.org/std/primitive.char.html">Rust <code>char</code> 文档</a></li>
<li>尽管 unit 类型<code>()</code>（一个空元组）在Rust中是 <em>可表达值(expressible value)</em>，C# 中最接近它的是表示“无”的 <code>void</code>。然而，仅当使用指针和 unsafe 代码时，<code>void</code> 才是 <em>可表达值</em>。.NET 中的 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.valuetuple"><code>ValueTuple</code></a> 是一个空元组，但是C#并没有像是 <code>()</code> 这种表示它的字面量语法。C# 中可以使用 <code>ValueTuple</code>，但这是很罕见的做法。不过，不同于 C# ，F# 拥有像 Rust 一样的 <a href="https://learn.microsoft.com/zh-cn/dotnet/fsharp/language-reference/unit-type">unit 类型</a>。</li>
<li>尽管 <code>void</code> 和 <code>object</code> 不是标量类型（甚至在 .NET 类型系统中 <code>int</code> 这种标量也是 <code>object</code> 的子类），方便起见它们也被列入上表中。</li>
</ol>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/primitives.html">Primitives (Rust By Example)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>Rust中有两种字符串类型：<code>String</code> 和 <code>str</code>，前者分配在堆上，后者则是到一个 <code>String</code> 或 <code>&amp;str</code> 的切片。</p>
<p>这些类型到 .NET 的映射关系如下：</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>.NET</th><th>备注</th></tr></thead><tbody>
<tr><td><code>&amp;mut str</code></td><td><code>Span&lt;char&gt;</code></td><td></td></tr>
<tr><td><code>&amp;str</code></td><td><code>ReadOnlySpan&lt;char&gt;</code></td><td></td></tr>
<tr><td><code>Box&lt;str&gt;</code></td><td><code>String</code></td><td>参见备注 1.</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td></td></tr>
<tr><td><code>String</code> (mutable)</td><td><code>StringBuilder</code></td><td>参见备注 1.</td></tr>
</tbody></table>
</div>
<p>在 Rust 和 .NET 中使用字符串的方式有所不同，不过可以从上面列出的大致的等价关系开始。其中一点是 Rust 字符串是 UTF-8 编码的，而 .NET 的则是 UTF-16 编码。此外，.NET 字符串是不可变的，但 Rust 字符串可以被声明为可变，例如 <code>let s = &amp;mut String::from(&quot;hello&quot;);</code>。</p>
<p>还有一些区别是由于所有权概念导致的。要了解 String 类型的所有权机制，参见 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#string-%E7%B1%BB%E5%9E%8B">Rust Book</a>.</p>
<p>备注：</p>
<ol>
<li>Rust 中的 <code>Box&lt;str&gt;</code> 类型和 .NET 的 <code>String</code> 类型是等价的。Rust中的 <code>Box&lt;str&gt;</code> 和 <code>String</code> 类型的区别是前者保存指针和长度，而后者保存指针、长度、还有容量，使得 <code>String</code> 长度可以增长。如果 Rust 的 <code>String</code> 声明为可变的，那么它与 .NET 中的 <code>StringBuilder</code> 类型很相似。</li>
</ol>
<p>C#：</p>
<pre><code class="language-csharp">ReadOnlySpan&lt;char&gt; span = &quot;Hello, World!&quot;;
string str = &quot;Hello, World!&quot;;
StringBuilder sb = new StringBuilder(&quot;Hello, World!&quot;);
</code></pre>
<p>Rust：</p>
<pre><code class="language-rust">let span: &amp;str = &quot;Hello, World!&quot;;
let str = Box::new(&quot;Hello World!&quot;);
let mut sb = String::from(&quot;Hello World!&quot;);</code></pre>
<h2 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h2>
<p>.NET 中的字符串字面量是分配在堆上的不可变的 <code>String</code> 类型。Rust 中则是 <code>&amp;'static str</code>，它是不可变的，具有全局生命周期且并非分配在堆上，而是直接嵌入编译后的二进制文件。</p>
<p>C#</p>
<pre><code class="language-csharp">string str = &quot;Hello, World!&quot;;
</code></pre>
<p>Rust</p>
<pre><code class="language-rust">let str: &amp;'static str = &quot;Hello, World!&quot;;</code></pre>
<p>C# 的逐字字符串字面量和 Rust 的原始字符串字面量等价。</p>
<pre><code class="language-csharp">string str = @&quot;Hello, \World/!&quot;;
</code></pre>
<p>Rust</p>
<pre><code class="language-rust">let str = r#&quot;Hello, \World/!&quot;#;</code></pre>
<p>C# 的 UTF-8 字符串字面量和 Rust 的字节字符串字面量等价。</p>
<p>C#</p>
<pre><code class="language-csharp">string str = &quot;hello&quot;u8;
</code></pre>
<p>Rust</p>
<pre><code class="language-rust">let str = b&quot;hello&quot;;</code></pre>
<h2 id="字符串内插值"><a class="header" href="#字符串内插值">字符串内插值</a></h2>
<p>C# 有内置的字符串内插功能，允许你在字符串字面量内嵌入表达式。下面是 C# 字符串内插的示例。</p>
<pre><code class="language-csharp">string name = &quot;John&quot;;
int age = 42;
string str = $&quot;Person {{ Name: {name}, Age: {age} }}&quot;;
</code></pre>
<p>Rust 没有内置的字符串内插功能。作为替代，<code>format!</code> 宏被用来格式化字符串。下面是 Rust 字符串内插的示例。</p>
<pre><code class="language-rust">let name = &quot;John&quot;;
let age = 42;
let str = format!(&quot;Person {{ name: {name}, age: {age} }}&quot;);</code></pre>
<p>在 C# 中，自定义类和结构体也可以被内插，因为所有类型都有继承自 <code>object</code> 的 <code>ToString()</code>方法。</p>
<pre><code class="language-csharp">class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    public override string ToString() =&gt;
        $&quot;Person {{ Name: {Name}, Age: {Age} }}&quot;;
}

var person = new Person { Name = &quot;John&quot;, Age = 42 };
Console.Writeline(person);
</code></pre>
<p>在 Rust 中，并非每一个类型都有默认的格式化实现/继承。相反，每一个需要转换到字符串的类型都必须实现 <code>std::fmt::Display</code> trait 。</p>
<pre><code class="language-rust">use std::fmt::*;

struct Person {
    name: String,
    age: i32,
}

impl Display for Person {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, &quot;Person {{ name: {}, age: {} }}&quot;, self.name, self.age)
    }
}

let person = Person {
    name: &quot;John&quot;.to_owned(),
    age: 42,
};

println!(&quot;{person}&quot;);</code></pre>
<p>另一种选择是使用 <code>std::fmt::Debug</code> trait，<code>Debug</code> trait 为所有标准类型实现，并且可以用于打印类型的内部表示。下面的例子展示了如何使用 <code>derive</code> 属性来使用 <code>Debug</code> trait 打印一个自定义结构体的内部表示。这种声明方式为 <code>Person</code> 结构体自动实现了 <code>Debug</code> trait：</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: i32,
}

let person = Person {
    name: &quot;John&quot;.to_owned(),
    age: 42,
};

println!(&quot;{person:?}&quot;);</code></pre>
<blockquote>
<p>备注： 使用 :? 格式化说明符会使用 <code>Debug</code> trait 来打印结构体，
省略该符号则会使用 <code>Display</code> trait。</p>
</blockquote>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/hello/print/print_debug.html?highlight=derive#debug">Rust by Example - Debug</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h1>
<p>.NET 中常用的对象和集合类型以及它们到 Rust 的映射</p>
<div class="table-wrapper"><table><thead><tr><th>C#</th><th>Rust</th></tr></thead><tbody>
<tr><td><code>Array</code></td><td><code>Array</code></td></tr>
<tr><td><code>List</code></td><td><code>Vec</code></td></tr>
<tr><td><code>Tuple</code></td><td><code>Tuple</code></td></tr>
<tr><td><code>Dictionary</code></td><td><code>HashMap</code></td></tr>
</tbody></table>
</div>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<p>在 Rust 和 .NET 中，定长数组以同样的方式支持。</p>
<p>C#:</p>
<pre><code class="language-csharp">int[] someArray = new int[2] { 1, 2 };
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let someArray: [i32; 2] = [1,2];</code></pre>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<p>Rust 中 <code>List&lt;T&gt;</code> 的等价物是 <code>Vec&lt;T&gt;</code>。数组可以转换成 Vec，反之亦然。</p>
<p>C#:</p>
<pre><code class="language-csharp">var something = new List&lt;string&gt;
{
    &quot;a&quot;,
    &quot;b&quot;
};

something.Add(&quot;c&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut something = vec![
    &quot;a&quot;.to_owned(),
    &quot;b&quot;.to_owned()
];

something.push(&quot;c&quot;.to_owned());</code></pre>
<h2 id="元组"><a class="header" href="#元组">元组</a></h2>
<p>C#:</p>
<pre><code class="language-csharp">var something = (1, 2)
Console.WriteLine($&quot;a = {something.Item1} b = {something.Item2}&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let something = (1, 2);
println!(&quot;a = {} b = {}&quot;, something.0, something.1);

// deconstruction supported
let (a, b) = something;
println!(&quot;a = {} b = {}&quot;, a, b);</code></pre>
<blockquote>
<p><strong>备注</strong>：Rust 元组的元素不像 C# 那般是可命名的。
唯一访问元组元素的办法就是使用该元素的索引，要么就解构元组。</p>
</blockquote>
<h2 id="字典"><a class="header" href="#字典">字典</a></h2>
<p>Rust 中 <code>Dictionary&lt;TKey,TValue&gt;</code> 的等价物是 <code>Hashmap&lt;K,V&gt;</code>。</p>
<p>C#:</p>
<pre><code class="language-csharp">var something = new Dictionary&lt;string, string&gt;
{
    { &quot;Foo&quot;, &quot;Bar&quot; },
    { &quot;Baz&quot;, &quot;Qux&quot; }
};

something.Add(&quot;hi&quot;, &quot;there&quot;);
</code></pre>
<p>Rust:</p>
<pre><code class="language-rust">let mut something = HashMap::from([
    (&quot;Foo&quot;.to_owned(), &quot;Bar&quot;.to_owned()),
    (&quot;Baz&quot;.to_owned(), &quot;Qux&quot;.to_owned())
]);

something.insert(&quot;hi&quot;.to_owned(), &quot;there&quot;.to_owned());</code></pre>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/collections/index.html">Rust 标准库 - 集合</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义类型"><a class="header" href="#自定义类型">自定义类型</a></h1>
<p>这些章节讨论开发自定义类型相关的主题。</p>
<ul>
<li><a href="language/custom-types/classes.html">类</a></li>
<li><a href="language/custom-types/records.html">记录</a></li>
<li><a href="language/custom-types/structs.html">结构</a></li>
<li><a href="language/custom-types/interfaces.html">接口</a></li>
<li><a href="language/custom-types/enums.html">枚举</a></li>
<li><a href="language/custom-types/members.html">成员</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类class"><a class="header" href="#类class">类（Class）</a></h1>
<p>Rust 没有类。 它只有 <a href="language/custom-types/structs.html">结构体（<code>struct</code>）</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="记录record"><a class="header" href="#记录record">记录（Record）</a></h1>
<p>Rust 没有任何构造可以创建记录， 既没有像 C# 中的 <code>record struct</code> 也没有 <code>record calss</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构struct"><a class="header" href="#结构struct">结构（Struct）</a></h1>
<p>Rust 和 C# 中的结构体有一些相同点：</p>
<ul>
<li>
<p>它们都通过 <code>struct</code> 关键字定义，但是 Rust 中，<code>struct</code> 只能定义数据/字段。函数和方法所表示的行为都单独定义在一个 <em>impl块</em> 中。</p>
</li>
<li>
<p>Rust 中结构可以实现多个 trait，就像 C# 中的可以实现多个接口。</p>
</li>
<li>
<p>它们无法派生类。</p>
</li>
<li>
<p>它们默认分配在栈上，除非：</p>
<ul>
<li>.NET 中，装箱或转换为接口类型。</li>
<li>Rust 中，包裹在 <code>Box</code>，<code>Rc</code>/<code>Arc</code> 等智能指针内。</li>
</ul>
</li>
</ul>
<p>在 C# 中，<code>struct</code> 是建立 .NET <em>值类型</em>，的办法，它们通常是一些领域特定的原始值，或是需要值等价性语义的复合类型。在 Rust 中，<code>struct</code> 是主要的建立数据类型的方式。（另一个是 <code>enum</code>）。</p>
<p>C# 中的 <code>struct</code> （或 <code>record struct</code>）默认拥有按值复制和值等价性语义。但在 Rust 中，这需要额外的一步，使用 <a href="https://doc.rust-lang.org/stable/reference/attributes/derive.html"><code>#derive</code> 属性</a> 并列出要实现的 trait。</p>
<pre><code class="language-rust">#[derive(Clone, Copy, PartialEq, Eq, Hash)]
struct Point {
    x: i32,
    y: i32,
}</code></pre>
<p>C#/.NET 中的值类型通常被开发者设计为不可变的。这被认为是符合语义的最佳实践，不过语言本身并不阻止设计一个具有破坏性和原地修改行为的 <code>struct</code>。Rust 中也一样。类型必须被开发者刻意地设计为可变的。</p>
<p>由于 Rust 没有类，因此也没有通过派生类实现的类型架构，共享行为通过 trait，泛型，以及通过使用 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html#%E9%A1%BE%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1">trait objects</a> 动态分发实现的多态。</p>
<p>假设下面这个 C# <code>struct</code> 表示一个矩形：</p>
<pre><code class="language-c#">struct Rectangle
{
    public Rectangle(int x1, int y1, int x2, int y2) =&gt;
        (X1, Y1, X2, Y2) = (x1, y1, x2, y2);

    public int X1 { get; }
    public int Y1 { get; }
    public int X2 { get; }
    public int Y2 { get; }

    public int Length =&gt; Y2 - Y1;
    public int Width =&gt; X2 - X1;

    public (int, int) TopLeft =&gt; (X1, Y1);
    public (int, int) BottomRight =&gt; (X2, Y2);

    public int Area =&gt; Length * Width;
    public bool IsSquare =&gt; Width == Length;

    public override string ToString() =&gt; $&quot;({X1}, {Y1}), ({X2}, {Y2})&quot;;
}
</code></pre>
<p>Rust 的等价实现：</p>
<pre><code class="language-rust">#![allow(dead_code)]

struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    pub fn x1(&amp;self) -&gt; i32 { self.x1 }
    pub fn y1(&amp;self) -&gt; i32 { self.y1 }
    pub fn x2(&amp;self) -&gt; i32 { self.x2 }
    pub fn y2(&amp;self) -&gt; i32 { self.y2 }

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn top_left(&amp;self) -&gt; (i32, i32) {
        (self.x1, self.y1)
    }

    pub fn bottom_right(&amp;self) -&gt; (i32, i32) {
        (self.x2, self.y2)
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }

    pub fn is_square(&amp;self)  -&gt; bool {
        self.width() == self.length()
    }
}

use std::fmt::*;

impl Display for Rectangle {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        write!(f, &quot;({}, {}), ({}, {})&quot;, self.x1, self.y2, self.x2, self.y2)
    }
}</code></pre>
<p>需要注意 C# 的 <code>struct</code> 继承了来自 <code>Object</code> 的 <code>ToString</code> 方法，因此，它可以通过 <em>重写</em> 基类实现来提供自定义的字符串表示。由于 Rust 中没有继承，类型对一些 <em>格式化</em> 表示的支持是通过实现 <code>Display</code> trait。这样该结构的实例就可以参与格式化，例如被 <code>println!</code> 打印。如下：</p>
<pre><code class="language-rust">fn main() {
    let rect = Rectangle::new(12, 34, 56, 78);
    println!(&quot;Rectangle = {rect}&quot;);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口interfaces"><a class="header" href="#接口interfaces">接口(Interfaces)</a></h1>
<p>Rust 没有 C#/.NET 中的接口。作为替代，它使用 <em>trait</em>。和接口类似，一个 trait 表示一种抽象，同时形成一种约束：当类型实现 trait 时，必须实现它的所有成员。</p>
<p>就像 C#/.NET 接口可以有默认方法（默认实现的方法体作为方法定义的一部分），Rust 中的 trait 也一样。实现接口/trait 的类型也可以随后提供一个更合适的或优化过的实现。</p>
<p>C#/.NET 的接口可以拥有所有类型的成员，属性、索引器、事件、方法等，既可以是静态的也可以是实例的。类似地，Rust trait 可以有（实例）方法、关联函数（当作是 C#/.NET 中的静态方法）、常量。</p>
<p>除了类架构，接口是通过动态分发实现多态的核心概念，这创造了横向的抽象。通过接口，可以编写针对接口的通用代码，而无需关心实现它的具体类型。Rust 的 trait 也可以有限地取得同样的效果。trait 对象实际上是一张 <em>v-table</em> （虚表），它通过 <code>dyn</code> 关键字后跟上 trait 名来标识，例如 <code>dyn Shape</code>（其中 <code>Shape</code> 是trait名）。trait 对象总是隐藏在指针之后，通过引用（例如 <code>&amp;dyn Shape</code>）或堆上的 <code>Box</code>（例如 <code>Box&lt;dyn Shape&gt;</code>。这与 .NET 有些类似，接口是引用类型，因此值类型转换成接口会被自动装箱到托管堆上。前文提到过 trait 对有些限制，那就是原始的实现类型无法被恢复。也就是说，虽然转换或者测试一个接口是否是某个实例是非常常见的场景，但在 Rust 中是不可能的（如果没有一些额外的工作和支持）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举enum"><a class="header" href="#枚举enum">枚举（Enum）</a></h1>
<p>C# 中，枚举是一种值类型，它将符号映射到整数值。</p>
<pre><code class="language-c#">enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}
</code></pre>
<p>Rust 有着 <em>完全一致</em> 语法做同样的事：</p>
<pre><code class="language-rust">enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}</code></pre>
<p>与 .NET 不同，Rust <code>enum</code> 实例没有任何预定义行为，甚至无法进行像 <code>dow == DayOfWeek::Friday</code> 这种简单的等价检验。为了赋予它一些和 C# <code>enum</code> 差不多的功能，需要使用 <a href="https://doc.rust-lang.org/stable/reference/attributes/derive.html"><code>#derive</code>属性</a> 来自动实现一些常用功能：</p>
<pre><code class="language-rust does_not_compile">#[derive(Debug,     // 为 &quot;{:?}&quot; 启用格式化
         Clone,     // Copy 需要
         Copy,      // 启用按值复制语义
         Hash,      // 为了在各种 map 中使用，启用哈希能力
         PartialEq  // 启用值等价性 (==)
)]
enum DayOfWeek
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

fn main() {
    let dow = DayOfWeek::Wednesday;
    println!(&quot;Day of week = {dow:?}&quot;);

    if dow == DayOfWeek::Friday {
        println!(&quot;Yay! It's the weekend!&quot;);
    }

    // 强制转换为整形
    let dow = dow as i32;
    println!(&quot;Day of week = {dow:?}&quot;);

    let dow = dow as DayOfWeek;
    println!(&quot;Day of week = {dow:?}&quot;);
}</code></pre>
<p>上面的例子表明，一个 <code>enum</code> 类型可以被强制转换到为它分配的整数类型，不过不像 C#，反过来的转换时不可行的（尽管这在 C#/.NET 中也有负面影响，即 <code>enum</code> 实例可能持有的是不存在的值）。反之，开发者需要来提供这一帮助函数：</p>
<pre><code class="language-rust">impl DayOfWeek {
    fn from_i32(n: i32) -&gt; Result&lt;DayOfWeek, i32&gt; {
        use DayOfWeek::*;
        match n {
            0 =&gt; Ok(Sunday),
            1 =&gt; Ok(Monday),
            2 =&gt; Ok(Tuesday),
            3 =&gt; Ok(Wednesday),
            4 =&gt; Ok(Thursday),
            5 =&gt; Ok(Friday),
            6 =&gt; Ok(Saturday),
            _ =&gt; Err(n)
        }
    }
}</code></pre>
<p>如果<code>n</code>是有效值，<code>from_i32</code> 函数返回一个包裹在表示成功（<code>Ok</code>）的 <code>Result</code> 中的 <code>DayOfWeek</code>，否则它将<code>n</code>包裹在表示失败（<code>Err</code>）的 <code>Result</code> 中原样返回。</p>
<pre><code class="language-rust">let dow = DayOfWeek::from_i32(5);
println!(&quot;{dow:?}&quot;); // prints: Ok(Friday)

let dow = DayOfWeek::from_i32(50);
println!(&quot;{dow:?}&quot;); // prints: Err(50)</code></pre>
<p>Rust 有一些 crate 可以帮助实现这种从整数类型的映射从而不必手动编码。</p>
<p>Rust 中的 <code>enum</code> 类型也是一种设计（可区分）联合类型的方式，它允许不同的 <em>成员</em>（<em>variants</em>）持有特定于自己的数据。例：</p>
<pre><code class="language-rust">enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));</code></pre>
<p>这种 <code>enum</code> 声明形式不存在于 C# 中，不过可以用（类）记录来模拟：</p>
<pre><code class="language-c#">var home = new IpAddr.V4(127, 0, 0, 1);
var loopback = new IpAddr.V6(&quot;::1&quot;);

abstract record IpAddr
{
    public sealed record V4(byte A, byte B, byte C, byte D): IpAddr;
    public sealed record V6(string Address): IpAddr;
}
</code></pre>
<p>二者不同之处在于 Rust 定义产生的是成员的 <em>封闭类型（closed type）</em>，也就是说编译器知道 <code>IpAddr</code> 没有除了 <code>IpAddr::V4</code> 和 <code>IpAddr::V6</code>之外的成员，并且可以借此执行更严格的检查，例如在 <code>match</code> 表达式（相当于 C# <code>switch</code> 表达式）中，Rust 编译器不会通过代码除非所有变体都已被覆盖。相比之下，C# 的模拟方案实际上创建了类架构（尽管表达很简单），并且由于 <code>IpAddr</code> 是一个 <em>抽象基类</em>，它能表示的所有类型集合对于编译器是未知的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="成员members"><a class="header" href="#成员members">成员（Members）</a></h1>
<h2 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h2>
<p>Rust 没有任何构造函数的表示法。相反，你可以之禅秀编写返回该类型实例的工厂函数。工厂函数可以是单独的也可以是该类型的 <em>关联函数</em>。用 C# 的说法，关联函数就像一个类型的静态方法。按照惯例，如果一个 <code>struct</code> 只有一个工厂函数，它应被命名为 <code>new</code>。</p>
<pre><code class="language-rust">struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }
}</code></pre>
<p>由于 Rust 函数（不管是否关联）不支持重载，这些工厂函数必须被唯一地命名。例如，下面是 <code>String</code> 类型可用的所谓构造函数或工厂函数：</p>
<ul>
<li><code>String::new</code>：创建空字符串</li>
<li><code>String::with_capacity</code>：创建带有指定初始缓冲区容量的字符串</li>
<li><code>String::from_utf8</code>：从一串 UTF-8 字节编码字符串。</li>
<li><code>String::from_utf16</code>：从一串 UTF-16 字节编码字符串。</li>
</ul>
<p>对于 Rust <code>enum</code> 类型的情况，它的变体成员就是构造函数。参见 <a href="language/custom-types/enums.html">enum 一节</a>。</p>
<p>另见：</p>
<ul>
<li>
<p><a href="https://rust-lang.github.io/api-guidelines/predictability.html?highlight=new#constructors-are-static-inherent-methods-c-ctor">Constructors are static, inherent methods (C-CTOR)</a></p>
</li>
</ul>
<h2 id="方法静态的和实例的"><a class="header" href="#方法静态的和实例的">方法（静态的和实例的）</a></h2>
<p>就像 C#，Rust 类型（<code>enum</code> 和 <code>struct</code> 都是）可以有静态和实例方法。在 Rust 语境中，<em>方法</em> 始终是实例上的，并且通过它的第一个参数是<code>self</code>来标识，<code>self</code> 参数没有类型标注，因为它始终是该方法所属的类型。静态方法则被称作 <em>关联函数</em>，下面的例子中，<code>new</code> 是一个关联函数，而剩下的（<code>length</code>、<code>width</code> 和 <code>area</code>）则是该类型的方法：</p>
<pre><code class="language-rust">struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}</code></pre>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>像 C# 一样，Rust 类型可以包含常量。不过，更有意思的一点是 Rust 允许类型实例被定义为常量：</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

impl Point {
    const ZERO: Point = Point { x: 0, y: 0 };
}</code></pre>
<p>C# 中，这需要静态只读字段来实现：</p>
<pre><code class="language-c#">readonly record struct Point(int X, int Y)
{
    public static readonly Point Zero = new(0, 0);
}
</code></pre>
<h2 id="事件"><a class="header" href="#事件">事件</a></h2>
<p>Rust 没有内置的支持来让类型成员广播和激发事件，不像 C#拥有 <code>event</code> 关键字。</p>
<h2 id="属性1"><a class="header" href="#属性1">属性<sup class="footnote-reference"><a href="#translator_note_attribute_vs_property">1</a></sup></a></h2>
<p>C# 中，类型字段通常是私有的，它们被属性成员保护/封装着，通过访问器方法（<code>get</code> 和 <code>set</code>）来读写字段。访问器方法可以包含额外逻辑，例如，设置值的时候进行验证或读取值的时候进行计算。Rust 只有方法，<a href="https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md#gettersetter-apis">getter 用字段名命名（Rust 中方法和字段的标识符可以一样），setter 则前缀 <code>set_</code></a></p>
<p>下面的例子演示了 Rust 中的类似属性的访问器方法：</p>
<pre><code class="language-rust">struct Rectangle {
    x1: i32, y1: i32,
    x2: i32, y2: i32,
}

impl Rectangle {
    pub fn new(x1: i32, y1: i32, x2: i32, y2: i32) -&gt; Self {
        Self { x1, y1, x2, y2 }
    }

    // 相当于属性 getter (都和对应的字段名一样)

    pub fn x1(&amp;self) -&gt; i32 { self.x1 }
    pub fn y1(&amp;self) -&gt; i32 { self.y1 }
    pub fn x2(&amp;self) -&gt; i32 { self.x2 }
    pub fn y2(&amp;self) -&gt; i32 { self.y2 }

    // 相当于属性 setter

    pub fn set_x1(&amp;mut self, val: i32) { self.x1 = val }
    pub fn set_y1(&amp;mut self, val: i32) { self.y1 = val }
    pub fn set_x2(&amp;mut self, val: i32) { self.x2 = val }
    pub fn set_y2(&amp;mut self, val: i32) { self.y2 = val }

    // 相当于计算属性

    pub fn length(&amp;self) -&gt; i32 {
        self.y2 - self.y1
    }

    pub fn width(&amp;self)  -&gt; i32 {
        self.x2 - self.x1
    }

    pub fn area(&amp;self)  -&gt; i32 {
        self.length() * self.width()
    }
}</code></pre>
<h2 id="扩展方法"><a class="header" href="#扩展方法">扩展方法</a></h2>
<p>C# 中的扩展方法允许开发者为现有类型附加新的静态绑定的方法，而不需要修改原有的类型定义。下面的 C# 示例中，通过 <em>扩展</em>，为 <code>StringBuilder</code> 类添加了一个新的 <code>Wrap</code> 方法：</p>
<pre><code class="language-csharp">using System;
using System.Text;
using Extensions; // (1)

var sb = new StringBuilder(&quot;Hello, World!&quot;);
sb.Wrap(&quot;&gt;&gt;&gt; &quot;, &quot; &lt;&lt;&lt;&quot;); // (2)
Console.WriteLine(sb.ToString()); // Prints: &gt;&gt;&gt; Hello, World! &lt;&lt;&lt;

namespace Extensions
{
    static class StringBuilderExtensions
    {
        public static void Wrap(this StringBuilder sb,
                                string left, string right) =&gt;
            sb.Insert(0, left).Append(right);
    }
}
</code></pre>
<p>注意为了使扩展方法可用（2），包含扩展方法的类型的命名空间必须先被引入（1）。Rust 通过 trait 提供了一种非常类似的方案，叫做 <em>扩展 trait</em>。下面的 Rust 例子和上面的 C# 例子等价，它为 <code>String</code> 扩展了方法 <code>wrap</code>：</p>
<pre><code class="language-rust">#![allow(dead_code)]

mod exts {
    pub trait StrWrapExt {
        fn wrap(&amp;mut self, left: &amp;str, right: &amp;str);
    }

    impl StrWrapExt for String {
        fn wrap(&amp;mut self, left: &amp;str, right: &amp;str) {
            self.insert_str(0, left);
            self.push_str(right);
        }
    }
}

fn main() {
    use exts::StrWrapExt as _; // (1)

    let mut s = String::from(&quot;Hello, World!&quot;);
    s.wrap(&quot;&gt;&gt;&gt; &quot;, &quot; &lt;&lt;&lt;&quot;); // (2)
    println!(&quot;{s}&quot;); // Prints: &gt;&gt;&gt; Hello, World! &lt;&lt;&lt;
}</code></pre>
<p>就像 C# 中那样，为了使扩展 trait 的方法可用（2），扩展 trait 必须先被导入（1）。还需要注意，扩展 trait 标识符 <code>StrWarpExt</code> 自身可以通过 <code>_</code> 被丢弃，这不会影响 <code>wrap</code> 对 <code>String</code> 的可用性。</p>
<h2 id="可见性访问修饰符"><a class="header" href="#可见性访问修饰符">可见性/访问修饰符</a></h2>
<p>C# 有许多可访问性，亦称可见性，修饰符：</p>
<ul>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>internal</code></li>
<li><code>protected internal</code> (family)</li>
<li><code>public</code></li>
</ul>
<p>Rust 中，编译过程就是构建一棵由模块组成的树，每个模块都包含并定义了若干<a href="https://doc.rust-lang.org/reference/items.html">程序项（items）</a>，比如类型、trait、枚举、常量和函数。几乎一切都是默认私有的。例外之一是，比如公共 trait 中的关联函数是默认公开的。类似的是 C# 的接口即使没有任何公共修饰符也是默认公开的。Rust 只有 <code>pub</code> 修饰符来改变在模块树中的可见性。<code>pub</code> 有一些变体改变了公开可见的作用域：</p>
<ul>
<li><code>pub(self)</code></li>
<li><code>pub(super)</code></li>
<li><code>pub(crate)</code></li>
<li><code>pub(in PATH)</code></li>
</ul>
<p>更多细节可以查看 Rust Reference 的 <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility and Privacy</a> 一节。</p>
<p>下表是 C# 和 Rust 修饰符的大致对照：</p>
<div class="table-wrapper"><table><thead><tr><th>C#</th><th>Rust</th><th>备注</th></tr></thead><tbody>
<tr><td><code>private</code></td><td>(default)</td><td>见备注 1.</td></tr>
<tr><td><code>protected</code></td><td>N/A</td><td>见备注 2.</td></tr>
<tr><td><code>internal</code></td><td><code>pub(crate)</code></td><td></td></tr>
<tr><td><code>protected internal</code> (family)</td><td>N/A</td><td>见备注 2.</td></tr>
<tr><td><code>public</code></td><td><code>pub</code></td><td></td></tr>
</tbody></table>
</div>
<ol>
<li>
<p>没有关键字来表明私有可见性，这是 Rust 的默认行为。</p>
</li>
<li>
<p>由于 Rust 中没有基于类的类型架构，也就没有 <code>protected</code> 的等价物了。</p>
</li>
</ol>
<h2 id="可变性"><a class="header" href="#可变性">可变性</a></h2>
<p>在 C# 中设计类型时，开发者可以自行决定类型是否可变、是否支持破坏性修变更。C# 也为 <em>positional record 声明</em>（<code>record class</code>或 <code>readonly record struct</code>） 支持不可变设计。在 Rust 中，可变性通过方法的 <code>self</code> 参数来表达，如下面的例子所示：</p>
<pre><code class="language-rust">struct Point { x: i32, y: i32 }

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Self {
        Self { x, y }
    }

    // self 不可变

    pub fn x(&amp;self) -&gt; i32 { self.x }
    pub fn y(&amp;self) -&gt; i32 { self.y }

    // self 可变

    pub fn set_x(&amp;mut self, val: i32) { self.x = val }
    pub fn set_y(&amp;mut self, val: i32) { self.y = val }
}</code></pre>
<p>C# 中，你可以用 <code>with</code> 来进行非破坏性变更：</p>
<pre><code class="language-c#">var pt = new Point(123, 456);
pt = pt with { X = 789 };
Console.WriteLine(pt.ToString()); // prints: Point { X = 789, Y = 456 }

readonly record struct Point(int X, int Y);
</code></pre>
<p>Rust 中没有 <code>with</code>，但是为了模拟类似的实现，它必须硬编码在类型设计中：</p>
<pre><code class="language-rust">struct Point { x: i32, y: i32 }

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Self {
        Self { x, y }
    }

    pub fn x(&amp;self) -&gt; i32 { self.x }
    pub fn y(&amp;self) -&gt; i32 { self.y }

    // following methods consume self and return a new instance

    pub fn set_x(self, val: i32) -&gt; Self { Self::new(val, self.y) }
    pub fn set_y(self, val: i32) -&gt; Self { Self::new(self.x, val) }
}</code></pre>
<hr />
<div class="footnote-definition" id="translator_note_attribute_vs_property"><sup class="footnote-definition-label">1</sup>
<p>译者注①：前文中也多次出现了“属性”一词，这里第一次出现 C# 语境下的 “属性”。由于 C# 和 Rust 社区的常用翻译不同，C# 中的属性指的是 Property，即封装字段的访问器。另一个词 Attribute 在 C# 中通常译作“特性”，即使用方括号 <code>[]</code> 包裹的用于为代码附加元信息的特殊类型，使用上类似于 Rust 中的 attribute macro，但这个词通常被 Rust 社区译为 “属性宏”。此译本的做法是，Property 始终译作“属性”，Attribute 在 C# 语境中译作“特性”，在 Rust 语境中译作“属性”。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="本地函数"><a class="header" href="#本地函数">本地函数</a></h1>
<p>C# 和 Rust 都有本地函数，不过 Rust 中的本地函数仅仅相当于 C# 中的静态本地函数。
也就是说，Rust 中的本地函数无法使用使用外部作用域的变量，但是 <em>闭包</em> 可以。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda表达式与闭包"><a class="header" href="#lambda表达式与闭包">Lambda表达式与闭包</a></h1>
<p>C# 和 Rust 允许函数用作一级值（first-class value），这使得可以编写 <em>高阶函数</em>。高阶函数可以接受其它函数作为参数，从而允许调用者参与被调用函数的代码。在 C# 中，<em>类型安全的函数指针</em> 由委托表示，最常见的就是 <code>Func</code> 和 <code>Action</code>。C# 允许通过 <em>lambda 表达式</em> 来临时声明这些委托。</p>
<p>Rust 也有函数指针，最简单的就是 <code>fn</code> 类型：</p>
<pre><code class="language-rust">fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(|x| x + 1, 5);
    println!(&quot;The answer is: {}&quot;, answer); // Prints: The answer is: 12
}</code></pre>
<p>但是，Rust 对 <em>函数指针</em>（<code>fn</code> 定义的类型） 和 <em>闭包</em> 做了区分：闭包可以引用环绕它的作用域的变量，但函数指针不可以。尽管 C# 也有 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers">函数指针</a> (<code>*delegate</code>)，但托管的、类型安全的等价替代是静态 lambda 表达式。</p>
<p>接受闭包的函数和方法都使用泛型类型编写，最终绑定到其中一种表示函数的 trait：<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>。当为函数指针和闭包提供值时， Rust 开发者使用 <em>闭包表达式</em> （例如上例中的 <code>|x| x + 1</code>），就像 C# 中的 lambda 表达式。闭包表达式创建函数指针还是闭包取决于闭包表达式是否引用了它的上下文。</p>
<p>当一个闭包从环境中捕获变量时，所有权规则也会参与其中，因为所有权最终会随着闭包而结束。更多信息参见《Rust 程序设计语言》的 “<a href="https://kaisery.github.io/trpl-zh-cn/ch13-01-closures.html#%E5%B0%86%E8%A2%AB%E6%8D%95%E8%8E%B7%E7%9A%84%E5%80%BC%E7%A7%BB%E5%87%BA%E9%97%AD%E5%8C%85%E5%92%8C-fn-trait">将被捕获的值移出闭包和 Fn trait</a>”一节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>下面是 C# 中变量赋值的例子：</p>
<pre><code class="language-csharp">int x = 5;
</code></pre>
<p>Rust 中同样的：</p>
<pre><code class="language-rust">let x: i32 = 5;</code></pre>
<p>目前看来，两个语言唯一的不同在于类型声明的位置。而且，C# 和 Rust 都是类型安全的：编译器会确保变量的值始终是它期望的类型。借助编译器自动推断变量类型的能力，上面的例子可以简写。C# 中：</p>
<pre><code class="language-csharp">var x = 5;
</code></pre>
<p>Rust 中：</p>
<pre><code class="language-rust">let x = 5;</code></pre>
<p>扩展一下第一个例子，要更新变量的值（重新赋值），C# 和 Rust 的行为就不同了：</p>
<pre><code class="language-csharp">var x = 5;
x = 6;
Console.WriteLine(x); // 6
</code></pre>
<p>In Rust, the identical statement will not compile:</p>
<pre><code class="language-rust">let x = 5;
x = 6; // Error: cannot assign twice to immutable variable 'x'.
println!(&quot;{}&quot;, x);</code></pre>
<p>Rust 中，变量默认是 <em>不可变</em> 的。一旦值绑定到了一个名称，变量值就不能再改变了。可以通过在变量名前添加 <a href="https://doc.rust-lang.org/std/keyword.mut.html"><code>mut</code></a> 来使其成为 <em>可变的</em>：</p>
<pre><code class="language-rust">let mut x = 5;
x = 6;
println!(&quot;{}&quot;, x); // 6</code></pre>
<p>Rust 提供了一种替代方案来解决上面例子的问题，而不需要可变性，就是使用变量 <em>隐藏</em>（shadowing）：</p>
<pre><code class="language-rust">let x = 5;
let x = 6;
println!(&quot;{}&quot;, x); // 6</code></pre>
<p>C# 也支持隐藏，例如，本地变量可以隐藏字段，类型成员可以隐藏基类成员。在 Rust 中，上面的例子演示了隐藏还允许改变变量的类型而不改变名称，这对于要转换数据为不同的类型而又不想每一次都给它们起不同的名字的情况十分有用。</p>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/races.html">Data races and race conditions</a>：更多关于可变性意义的内容</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/variable_bindings/scope.html#scope-and-shadowing">Scope and shadowing</a></li>
<li><a href="language/../memory-management/index.html">内存管理</a> 解释了 <em>移动</em> 和 <em>所有权</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h1>
<p>命名空间在 .NET 中用于整理类型，也用来控制项目中类型和方法的作用域。</p>
<p>在 Rust 中，命名空间是一个不同的概念。Rust 中命名空间的等价物是<a href="https://doc.rust-lang.org/reference/items/modules.html">模块</a>。不管是 C# 还是 Rust，程序项的可见性都能够用可访问性修饰符，又叫可见性修饰符，来限制。Rust 中，默认的可见性是 <em>私有的（private）</em>（只有少数例外）。Rust 中和 C# 的 <code>public</code> 等价的是 <code>pub</code>，<code>internal</code> 则相当于 <code>pub(crate)</code>。如果需要更多细粒度的访问控制，参考 <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility modifiers</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="相等性"><a class="header" href="#相等性">相等性</a></h1>
<p>C# 中，比较相等性有时是指检验 <em>相等</em>（又称 <em>值相等</em>），有时是指检验_引用相等_，这是检验两个变量是否指向内存中的同一个底层对象。每一个自定义类型都可以用上面提到的其中一种语义来比较相等性，因为它继承自 <code>System.Object</code>（或 <code>System.ValueType</code>，它又继承自 <code>System.Object</code>）。</p>
<p>例如，在 C# 中比较值相等性和引用相等性：</p>
<pre><code class="language-csharp">var a = new Point(1, 2);
var b = new Point(1, 2);
var c = a;
Console.WriteLine(a == b); // (1) True
Console.WriteLine(a.Equals(b)); // (1) True
Console.WriteLine(a.Equals(new Point(2, 2))); // (1) True
Console.WriteLine(ReferenceEquals(a, b)); // (2) False
Console.WriteLine(ReferenceEquals(a, c)); // (2) True

record Point(int X, int Y);
</code></pre>
<ol>
<li>
<p><code>record Point</code> 上的相等操作符 <code>==</code> 和 <code>Equals</code> 方法会比较值相等性，因为记录默认支持值类型相等语义。</p>
</li>
<li>
<p>比较引用相等性是检验变量是否指向内存中的同一个底层对象。</p>
</li>
</ol>
<p>Rust 中的等价实现：</p>
<pre><code class="language-rust">#[derive(Copy, Clone)]
struct Point(i32, i32);

fn main() {
    let a = Point(1, 2);
    let b = Point(1, 2);
    let c = a;
    println!(&quot;{}&quot;, a == b); // Error: &quot;an implementation of `PartialEq&lt;_&gt;` might be missing for `Point`&quot;
    println!(&quot;{}&quot;, a.eq(&amp;b));
    println!(&quot;{}&quot;, a.eq(&amp;Point(2, 2)));
}</code></pre>
<p>上面的编译器报错展示了 Rust 的相等比较 <em>总是</em> 和 trait 实现相关。要支持使用 <code>==</code> 的比较，类型必须实现 <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>。</p>
<p>要修复上面的实例就是要为 <code>Point</code> 实现 <code>PartialEq</code>。默认情况下，派生 <code>PartialEq</code> 会比较所有字段的相等性，这些字段本身也必须实现 <code>PartialEq</code>。这类似 C# 中记录的等价性。</p>
<pre><code class="language-rust">#[derive(Copy, Clone, PartialEq)]
struct Point(i32, i32);

fn main() {
    let a = Point(1, 2);
    let b = Point(1, 2);
    let c = a;
    println!(&quot;{}&quot;, a == b); // true
    println!(&quot;{}&quot;, a.eq(&amp;b)); // true
    println!(&quot;{}&quot;, a.eq(&amp;Point(2, 2))); // false
    println!(&quot;{}&quot;, a.eq(&amp;c)); // true
}</code></pre>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>：更严格版本的 <code>PartialEq</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p>C# 中的泛型提供了一种定义使用其它类型作为参数的类型和方法的方式。这提高了代码的重用性、类型安全和性能（例如，避免了运行时类型强制转换）。考虑下面这个示例，这是一个泛型类型，它为任何值添加一个时间戳：</p>
<pre><code class="language-csharp">using System;

sealed record Timestamped&lt;T&gt;(DateTime Timestamp, T Value)
{
    public Timestamped(T value) : this(DateTime.UtcNow, value) { }
}
</code></pre>
<p>Rust 也有泛型，这是上面的等价实现：</p>
<pre><code class="language-rust">use std::time::*;

struct Timestamped&lt;T&gt; { value: T, timestamp: SystemTime }

impl&lt;T&gt; Timestamped&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, timestamp: SystemTime::now() }
    }
}</code></pre>
<p>另见：</p>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html">泛型数据类型</a></li>
</ul>
<h2 id="泛型类型约束"><a class="header" href="#泛型类型约束">泛型类型约束</a></h2>
<p>C# 中，通过使用 <code>where</code> 子句，<a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters">泛型类型可以被约束</a>。 下例展示了 C# 中的这种约束：</p>
<pre><code class="language-csharp">using System;

// 备注：记录自动实现了 `IEquatable`。
// 为了和 Rust 比较，下面的实现显式表明了这一行为。
sealed record Timestamped&lt;T&gt;(DateTime Timestamp, T Value) :
    IEquatable&lt;Timestamped&lt;T&gt;&gt;
    where T : IEquatable&lt;T&gt;
{
    public Timestamped(T value) : this(DateTime.UtcNow, value) { }

    public bool Equals(Timestamped&lt;T&gt;? other) =&gt;
        other is { } someOther
        &amp;&amp; Timestamp == someOther.Timestamp
        &amp;&amp; Value.Equals(someOther.Value);

    public override int GetHashCode() =&gt; HashCode.Combine(Timestamp, Value);
}
</code></pre>
<p>Rust 中同样可以做到：</p>
<pre><code class="language-rust">use std::time::*;

struct Timestamped&lt;T&gt; { value: T, timestamp: SystemTime }

impl&lt;T&gt; Timestamped&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, timestamp: SystemTime::now() }
    }
}

impl&lt;T&gt; PartialEq for Timestamped&lt;T&gt;
    where T: PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.value == other.value &amp;&amp; self.timestamp == other.timestamp
    }
}</code></pre>
<p>在 Rust 中，泛型类型约束叫做 <a href="https://doc.rust-lang.org/rust-by-example/generics/bounds.html"><code>bounds</code></a>。</p>
<p>C# 版本中， <code>Timestamped&lt;T&gt;</code> 实例 <em>仅</em> 可以为自身实现了 <code>IEquatable&lt;T&gt;</code> 的 <code>T</code> 类型创建。但是注意，Rust 版本更加灵活，因为它的 <code>Timestamped&lt;T&gt;</code> <em>有条件地实现了</em> <code>PartialEq</code>。这意味着 <code>Timestamped&lt;T&gt;</code> 实例仍然可以为不可比较的 <code>T</code> 类型创建，但是此时 <code>Timestamped&lt;T&gt;</code> 不会为这个 <code>T</code> 通过 <code>PartialEq</code> 实现相等性。</p>
<p>另见：</p>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">trait 作为参数</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E8%BF%94%E5%9B%9E%E5%AE%9E%E7%8E%B0%E4%BA%86-trait-%E7%9A%84%E7%B1%BB%E5%9E%8B">返回实现了 trait 的类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多态"><a class="header" href="#多态">多态</a></h1>
<p>Rust 不支持类和子类因此多态无法用 C# 中一样的方法实现。</p>
<p>另见：</p>
<ul>
<li>使用 <em>trait objects</em> 动态分发, 在<a href="language/./custom-types/structs.html">结构</a>一节讨论过</li>
<li><a href="language/./generics.html">泛型</a></li>
<li><a href="language/./inheritance.html">继承</a></li>
<li><a href="language/./operator-overloading.html">运算符重载</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="继承"><a class="header" href="#继承">继承</a></h1>
<p>在<a href="language/./custom-types/structs.html">结构</a>一节中解释过，不像 C#，Rust 不提供（基于类的）继承。一种为结构提供共享行为的方法是使用 trait。然而， 就像 C# 中的 <em>接口继承</em>，Rust 允许定义 trait 之间的关系，通过使用<a href="https://kaisery.github.io/trpl-zh-cn/ch19-03-advanced-traits.html#%E7%88%B6-trait-%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA-trait-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9F%90-trait-%E7%9A%84%E5%8A%9F%E8%83%BD"><em>父 trait</em></a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h1>
<p>在 .NET 中，异常是一种派生自 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.exception?view=net-6.0"><code>System.Exception</code></a> 的类。如果一段代码发生了问题，那么异常就会被抛出。抛出的异常会沿着栈传递，直到应用程序处理了它，或者程序终止。</p>
<p>Rust 没有异常，但是区分了 <em>可恢复</em> 与 <em>不可恢复</em> 的错误。一个可恢复的错误代表着一个应当被报告的问题，但是程序为此继续运行。对于可能会因可恢复的错误而失败的操作，它的的结果是类型 <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T,E&gt;</code></a>，其中 <code>E</code> 是错误变体的类型。<a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> 宏会在程序遇到不可恢复的错误时终止程序。不可恢复的错误总是意味着漏洞的存在。</p>
<h2 id="自定义错误类型"><a class="header" href="#自定义错误类型">自定义错误类型</a></h2>
<p>在 .NET 中， 自定义异常从 <code>Exception</code> 类派生。关于 <a href="https://learn.microsoft.com/zh-cn/dotnet/standard/exceptions/how-to-create-user-defined-exceptions">如何创建用户定义的异常</a> 的文档提到了这个例子：</p>
<pre><code class="language-csharp">public class EmployeeListNotFoundException : Exception
{
    public EmployeeListNotFoundException() { }

    public EmployeeListNotFoundException(string message)
        : base(message) { }

    public EmployeeListNotFoundException(string message, Exception inner)
        : base(message, inner) { }
}
</code></pre>
<p>在 Rust 中，可以通过实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait 来实现错误值的基本要求。Rust 中最简短的用户定义错误实现是：</p>
<pre><code class="language-rust">#[derive(Debug)]
pub struct EmployeeListNotFound;

impl std::fmt::Display for EmployeeListNotFound {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_str(&quot;Could not find employee list.&quot;)
    }
}

impl std::error::Error for EmployeeListNotFound {}</code></pre>
<p>.NET 中 <code>Exception.InnerException</code> 属性的等价是 Rust 中的 <code>Error::source()</code> 方法。然而，对 <code>Error::source()</code> 的实现并非必要的，通用(默认的)实现返回一个 <code>None</code>。</p>
<h2 id="引发异常"><a class="header" href="#引发异常">引发异常</a></h2>
<p>要在 C# 中引发异常，抛出一个异常的实例：</p>
<pre><code class="language-csharp">void ThrowIfNegative(int value)
{
    if (value &lt; 0)
    {
        throw new ArgumentOutOfRangeException(nameof(value));
    }
}
</code></pre>
<p>对于 Rust 中的可恢复错误，方法应当返回一个 <code>Ok</code> 或 <code>Err</code> 变体：</p>
<pre><code class="language-rust">fn error_if_negative(value: i32) -&gt; Result&lt;(), &amp;'static str&gt; {
    if value &lt; 0 {
        Err(&quot;Specified argument was out of the range of valid values. (Parameter 'value')&quot;)
    } else {
        Ok(())
    }
}</code></pre>
<p><a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a> 宏创建不可恢复的错误：</p>
<pre><code class="language-rust">fn panic_if_negative(value: i32) {
    if value &lt; 0 {
        panic!(&quot;Specified argument was out of the range of valid values. (Parameter 'value')&quot;)
    }
}</code></pre>
<h2 id="错误传播"><a class="header" href="#错误传播">错误传播</a></h2>
<p>在 .NET 中，异常会沿着调用栈传递直到它们被处理或者程序终止。在 Rust 中，不可恢复的错误表现类似，不过通常不会处理它们。</p>
<p>然而，可恢复的错误需要被显式地传播和处理。它们的存在总是由 Rust 函数或方法的签名表示。在 C# 中，捕获异常允许你对错误的存在与否进行处理：</p>
<pre><code class="language-csharp">void Write()
{
    try
    {
        File.WriteAllText(&quot;file.txt&quot;, &quot;content&quot;);
    }
    catch (IOException)
    {
        Console.WriteLine(&quot;Writing to file failed.&quot;);
    }
}
</code></pre>
<p>在 Rust 中，这大致相当于：</p>
<pre><code class="language-rust">fn write() {
    match std::fs::File::create(&quot;temp.txt&quot;)
        .and_then(|mut file| std::io::Write::write_all(&amp;mut file, b&quot;content&quot;))
    {
        Ok(_) =&gt; {}
        Err(_) =&gt; println!(&quot;Writing to file failed.&quot;),
    };
}</code></pre>
<p>大多数情况下，可恢复错误更需要被传播而不是处理。这种情况下，方法签名需要与要传播的错误类型兼容。<a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-"><code>?</code> 运算符</a> 以一种符合人体工学的方式传播错误。</p>
<pre><code class="language-rust">fn write() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut file = std::fs::File::create(&quot;file.txt&quot;)?;
    std::io::Write::write_all(&amp;mut file, b&quot;content&quot;)?;
    Ok(())
}</code></pre>
<p><strong>备注</strong>：若要使用问号运算符来传播错误，错误实现必须 <em>兼容</em>，就像<a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF%E7%9A%84%E7%AE%80%E5%86%99-%E8%BF%90%E7%AE%97%E7%AC%A6">传播错误的简写：? 运算符</a>中提到的。最一般的错误类型是错误的 <a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait 对象</a> <code>Box&lt;dyn Error&gt;</code>。</p>
<h2 id="堆栈跟踪"><a class="header" href="#堆栈跟踪">堆栈跟踪</a></h2>
<p>在 .NET 中抛出异常会导致运行时打印堆栈跟踪信息，这样可以借助额外的上下文来调试问题。</p>
<p>对于 Rust 中的可恢复错误，<a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E4%BD%BF%E7%94%A8-panic-%E7%9A%84-backtrace"><code>panic</code> backtrace</a> 提供了类似行为。</p>
<p>stable Rust 中的可恢复错误还不支持 backtrace，不过它当前已有实验性支持，通过使用<a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.provide">provide 方法</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable-和-option"><a class="header" href="#nullable-和-option">Nullable 和 Option</a></h1>
<p>在 C# 中，<code>null</code> 通常用来表示不存在、缺失或逻辑上未初始化的值。例如：</p>
<pre><code class="language-csharp">int? some = 1;
int? none = null;
</code></pre>
<p>Rust 没有 <code>null</code> 从而也就没有启用可为 null 的上下文的说法。作为替代，可选的或不存在的值用 <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a> 表示。上面的 C# 代码的 Rust 等价实现是：</p>
<pre><code class="language-rust">let some: Option&lt;i32&gt; = Some(1);
let none: Option&lt;i32&gt; = None;</code></pre>
<p>Rust 的 <code>Option&lt;T&gt;</code> 实际上和 F# 的 <a href="https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-option-1.html"><code>'T option</code></a> 一致。</p>
<h2 id="带有可选项的控制流"><a class="header" href="#带有可选项的控制流">带有可选项的控制流</a></h2>
<p>在 C# 中，你可能会使用 <code>if</code>/<code>else</code> 语句来控制带有可为 null 值时的程序流。</p>
<pre><code class="language-csharp">uint? max = 10;
if (max is { } someMax)
{
    Console.WriteLine($&quot;The maximum is {someMax}.&quot;); // The maximum is 10.
}
</code></pre>
<p>在 Rust 中你可以用模式匹配取得同样的行为：</p>
<p>使用 <code>if let</code> 甚至会更简单：</p>
<pre><code class="language-rust">let max = Some(10u32);
if let Some(max) = max {
    println!(&quot;The maximum is {}.&quot;, max); // The maximum is 10.
}</code></pre>
<h2 id="null-条件运算符"><a class="header" href="#null-条件运算符">Null 条件运算符</a></h2>
<p>C# 的 Null 条件运算符（<code>?.</code>和<code>?[]</code>）使得处理 <code>null</code> 更人性化。在 Rust 中，它们最好的替代就是使用 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>map</code></a> 方法。下面的代码段展示了对照：</p>
<pre><code class="language-csharp">string? some = &quot;Hello, World!&quot;;
string? none = null;
Console.WriteLine(some?.Length); // 13
Console.WriteLine(none?.Length); // (blank)
</code></pre>
<pre><code class="language-rust">let some: Option&lt;String&gt; = Some(String::from(&quot;Hello, World!&quot;));
let none: Option&lt;String&gt; = None;
println!(&quot;{:?}&quot;, some.map(|s| s.len())); // Some(13)
println!(&quot;{:?}&quot;, none.map(|s| s.len())); // None</code></pre>
<h2 id="null-合并运算符"><a class="header" href="#null-合并运算符">Null 合并运算符</a></h2>
<p>Null 合并运算符（<code>??</code>）常用于当一个可为 null 的值为 <code>null</code> 时默认为另一个值：</p>
<pre><code class="language-csharp">int? some = 1;
int? none = null;
Console.WriteLine(some ?? 0); // 1
Console.WriteLine(none ?? 0); // 0
</code></pre>
<p>在 Rust 中，你可以通过 <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or"><code>unwrap_or</code></a> 来取得同样的行为：</p>
<pre><code class="language-rust">let some: Option&lt;i32&gt; = Some(1);
let none: Option&lt;i32&gt; = None;
println!(&quot;{:?}&quot;, some.unwrap_or(0)); // 1
println!(&quot;{:?}&quot;, none.unwrap_or(0)); // 0</code></pre>
<p><strong>备注</strong>：如果默认值的计算很昂贵，你可以使用 <code>unwrap_or_else</code> 替代。它接收闭包作为参数，因此可以懒加载默认值。</p>
<h2 id="null-包容运算符"><a class="header" href="#null-包容运算符">Null 包容运算符</a></h2>
<p>Null 包容运算符（<code>!</code>）在 Rust 中没有对应的构造，因为在 C# 中，它也仅仅是影响编译器的静态分析。在 Rust 中，不需要它这样的存在。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="弃元"><a class="header" href="#弃元">弃元</a></h1>
<p>在 C# 中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/functional/discards">弃元</a> 表示编译器和其它工具链会忽略一个表达式的（部分）结果。</p>
<p>有多种上下文可以用到这个，例如最基本的，忽略一个表达式的结果。 在 C# 中，像这样：</p>
<pre><code class="language-csharp">_ = city.GetCityInformation(cityName);
</code></pre>
<p>在 Rust 中，<a href="https://kaisery.github.io/trpl-zh-cn/ch18-03-pattern-syntax.html#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC">忽略表达式的值</a> 看上去完全一致：</p>
<pre><code class="language-rust">_ = city.get_city_information(city_name);</code></pre>
<p>在 C# 中，弃元也用于解构元组：</p>
<pre><code class="language-csharp">var (_, second) = (&quot;first&quot;, &quot;second&quot;);
</code></pre>
<p>Rust 中，完全一致：</p>
<pre><code class="language-rust">let (_, second) = (&quot;first&quot;, &quot;second&quot;);</code></pre>
<p>除了解构元组，Rust 还提供了对结构和枚举的<a href="https://doc.rust-lang.org/reference/patterns.html#destructuring">解构</a>，通过使用 <code>..</code>，它表示类型的剩余部分：</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x), // x is 0
}</code></pre>
<p>当进行模式匹配时，忽略一部分匹配表达式是很有用的，例如 C# 中：</p>
<pre><code class="language-csharp">_ = (&quot;first&quot;, &quot;second&quot;) switch
{
    (&quot;first&quot;, _) =&gt; &quot;first element matched&quot;,
    (_, _) =&gt; &quot;first element did not match&quot;
};
</code></pre>
<p>同样的，Rust 的看起来也几乎一致：</p>
<pre><code class="language-rust">_ = match (&quot;first&quot;, &quot;second&quot;)
{
    (&quot;first&quot;, _) =&gt; &quot;first element matched&quot;,
    (_, _) =&gt; &quot;first element did not match&quot;
};</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h1>
<p>C# 和 Rust 在编译时都是静态类型的。因此，一旦声明了一个变量，后续再为它赋值一个不同类型的值是不被允许的
（除非该值可以隐式转换到目标类型）。C# 中有好几种类型转换的方式，Rust中也有和它们相对的存在。</p>
<h2 id="隐式转换"><a class="header" href="#隐式转换">隐式转换</a></h2>
<p>C# 中有隐式转换，Rust 也是（这被称作<a href="https://doc.rust-lang.org/reference/type-coercions.html">强制类型转换（Type coercion）</a>）。参考这个例子：</p>
<pre><code class="language-csharp">int intNumber = 1;
long longNumber = intNumber;
</code></pre>
<p>Rust 对于对于强制类型转换更严格：</p>
<pre><code class="language-rust">let int_number: i32 = 1;
let long_number: i64 = int_number; // error: expected `i64`, found `i32`</code></pre>
<p>一个有效的隐式转换的例子，通过使用 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md#subtyping">子类型（subtyping）</a>：</p>
<pre><code class="language-rust">fn bar&lt;'a&gt;() {
    let s: &amp;'static str = &quot;hi&quot;;
    let t: &amp;'a str = s;
}</code></pre>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">Deref coercion</a></li>
<li><a href="https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance">Subtyping and variance</a></li>
</ul>
<h2 id="显式转换"><a class="header" href="#显式转换">显式转换</a></h2>
<p>如果转换可能导致丢失信息，C# 需要使用强制转换表达式来显式转换：</p>
<pre><code class="language-csharp">double a = 1.2;
int b = (int)a;
</code></pre>
<p>当向下转换时，显式转换可能会在运行时失败，并抛出 <code>OverflowException</code> 或 <code>InvalidCastException</code> 之类的异常。</p>
<p>Rust 不提供原始类型之间的强制转换，不过可以使用 as<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">as.rs</a> 关键字来进行<a href="https://doc.rust-lang.org/rust-by-example/types/cast.html">显式转换</a>。Rust 中显式转换不会引发 panic。</p>
<pre><code class="language-rust">let int_number: i32 = 1;
let long_number: i64 = int_number as _;</code></pre>
<h2 id="自定义转换"><a class="header" href="#自定义转换">自定义转换</a></h2>
<p>通常，.NET 类型提供用户定义的转换运算符来将一个类型转换成另一个。另外，<code>System.IConvertible</code> 也是为了类型互相转换而存在的。</p>
<p>再 Rust 中，标准库包含将一个值转换成另一种类型的抽象，通过 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> trait 和与它对应的 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>。当为一个类型实现 <code>From</code> 时，会自动提供一个默认的 <code>Into</code> 实现（在 Rust 中叫做 <em>通用实现</em>）。下例演示了这两种类型转换：</p>
<pre><code class="language-rust">fn main() {
    let my_id = MyId(&quot;id&quot;.into()); // 由于为 `String` 实现了 `from&lt;&amp;str&gt;` trait，`into()` 也自动实现了。
    println!(&quot;{}&quot;, String::from(my_id)); // 这使用 `String` 的 `From&lt;MyId&gt;` 实现。
}

struct MyId(String);

impl From&lt;MyId&gt; for String {
    fn from(MyId(value): MyId) -&gt; Self {
        value
    }
}</code></pre>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>，<code>From</code>
和 <code>Into</code> 的可失败的版本。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h1>
<p>在 C# 中，自定义类型可以重载 <em>可重载运算符</em>。考虑下面这个 C# 示例：</p>
<pre><code class="language-csharp">Console.WriteLine(new Fraction(5, 4) + new Fraction(1, 2));  // 14/8

public readonly record struct Fraction(int Numerator, int Denominator)
{
    public static Fraction operator +(Fraction a, Fraction b) =&gt;
        new(a.Numerator * b.Denominator + b.Numerator * a.Denominator, a.Denominator * b.Denominator);

    public override string ToString() =&gt; $&quot;{Numerator}/{Denominator}&quot;;
}
</code></pre>
<p>在 Rust 中，大多数运算符<a href="https://doc.rust-lang.org/core/ops/">可以通过 trait 重载</a>。之所以这样可行是因为运算符是方法调用的语法糖。例如， <code>a + b</code> 中的 <code>+</code> 运算符调用了 <code>add</code> 方法。（参见 <a href="https://doc.rust-lang.org/rust-by-example/trait/ops.html">operator overloading</a>）。</p>
<pre><code class="language-rust">use std::{fmt::{Display, Formatter, Result}, ops::Add};

struct Fraction {
    numerator: i32,
    denominator: i32,
}

impl Display for Fraction {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result {
        f.write_fmt(format_args!(&quot;{}/{}&quot;, self.numerator, self.denominator))
    }
}

impl Add&lt;Fraction&gt; for Fraction {
    type Output = Fraction;

    fn add(self, rhs: Fraction) -&gt; Fraction {
        Fraction {
            numerator: self.numerator * rhs.denominator + rhs.numerator * self.denominator,
            denominator: self.denominator * rhs.denominator,
        }
    }
}

fn main() {
    println!(
        &quot;{}&quot;,
        Fraction { numerator: 5, denominator: 4 } + Fraction { numerator: 1, denominator: 2 }
    ); // 14/8
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h1>
<p>C# 提供一种使用包含 xml 文本的注释语法来为类型 API 编写文档的方案。C# 编译器会产生一个 xml 文件，它包含了表示注释和 API 签名的结构化数据。其他工具可以将该输出处理为另一种人类可读的文档形式。一个 C# 中的简单示例：</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// This is a document comment for &lt;c&gt;MyClass&lt;/c&gt;.
/// &lt;/summary&gt;
public class MyClass {}
</code></pre>
<p>Rust <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">文档注释</a>提供了和 C# 中同等的功能。Rust 文档注释使用 Markdown 语法。<a href="https://doc.rust-lang.org/rustdoc/index.html"><code>rustdoc</code></a> 是 Rust 代码的文档编译器，通常通过 <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html"><code>cargo doc</code></a> 调用，这会将注释编译为文档。例如：</p>
<pre><code class="language-rust">/// This is a doc comment for `MyStruct`.
struct MyStruct;</code></pre>
<p>.NET SDK 中并没有 <code>dotnet doc</code> 之类的和 <code>cargo doc</code> 对应的命令。</p>
<p>另见：</p>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">How to write documentation</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">Documentation tests</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源管理"><a class="header" href="#资源管理">资源管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程操作"><a class="header" href="#线程操作">线程操作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="同步"><a class="header" href="#同步">同步</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生产者-消费者"><a class="header" href="#生产者-消费者">生产者-消费者</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基准测试"><a class="header" href="#基准测试">基准测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志记录和跟踪"><a class="header" href="#日志记录和跟踪">日志记录和跟踪</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件编译"><a class="header" href="#条件编译">条件编译</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="环境与配置"><a class="header" href="#环境与配置">环境与配置</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linq"><a class="header" href="#linq">LINQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元编程"><a class="header" href="#元编程">元编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译与构建"><a class="header" href="#编译与构建">编译与构建</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
